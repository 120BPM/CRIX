crix_accuracy = accuracy(crix_forecast, forecast_crix[(length(forecast_crix)-14):length(forecast_crix)])
index_SP500_arima = auto.arima(forecast_SP500[1:(length(forecast_SP500)-14)], ic = "aic")
index_SP500_forecast = forecast.Arima(index_SP500_arima, h = 14)
index_SP500_accuracy = accuracy(index_SP500_forecast, forecast_SP500[(length(forecast_SP500)-14):length(forecast_SP500)])
index_DAX_arima = auto.arima(forecast_DAX[1:(length(forecast_DAX)-14)], ic = "aic")
index_DAX_forecast = forecast.Arima(index_DAX_arima, h = 14)
index_DAX_accuracy = accuracy(index_DAX_forecast, forecast_DAX[(length(forecast_DAX)-14):length(forecast_DAX)])
index_STI_arima = auto.arima(forecast_STI[1:(length(forecast_STI)-14)], ic = "aic")
index_STI_forecast = forecast.Arima(index_STI_arima, h = 14)
index_STI_accuracy = accuracy(index_STI_forecast, forecast_STI[(length(forecast_STI)-14):length(forecast_STI)])
index_RTSI_arima = auto.arima(forecast_RTSI[1:(length(forecast_RTSI)-14)], ic = "aic")
index_RTSI_forecast = forecast.Arima(index_RTSI_arima, h = 14)
index_RTSI_accuracy = accuracy(index_RTSI_forecast, forecast_RTSI[(length(forecast_RTSI)-14):length(forecast_RTSI)])
index_ATHEX_arima = auto.arima(forecast_ATHEX[1:(length(forecast_ATHEX)-14)], ic = "aic")
index_ATHEX_forecast = forecast.Arima(index_ATHEX_arima, h = 14)
index_ATHEX_accuracy = accuracy(index_ATHEX_forecast, forecast_ATHEX[(length(forecast_ATHEX)-14):length(forecast_ATHEX)])
# index_t_v_all = index_comp_all("dummy")
# index_t_v_10 = index_comp(10)
# index_t_v_15 = index_comp(15)
# index_t_v_20 = index_comp(20)
# index_t_v_25 = index_comp(25)
# index_t_v_30 = index_comp(30)
# index_t_v_35 = index_comp(35)
#
# plot_diff10 = index_t_v_all[[1]] - index_t_v_10[[1]]
# plot_diff15 = index_t_v_all[[1]] - index_t_v_15[[1]]
# plot_diff20 = index_t_v_all[[1]] - index_t_v_20[[1]]
# plot_diff25 = index_t_v_all[[1]] - index_t_v_25[[1]]
# plot_diff30 = index_t_v_all[[1]] - index_t_v_30[[1]]
# plot_diff35 = index_t_v_all[[1]] - index_t_v_35[[1]]
#
#
# sf1f = stableFit(plot_diff10, type = "mle")
# sf2f = stableFit(plot_diff15, type = "mle")
# sf3f = stableFit(plot_diff20, type = "mle")
# sf4f = stableFit(plot_diff25, type = "mle")
# sf5f = stableFit(plot_diff30, type = "mle")
# sf6f = stableFit(plot_diff35, type = "mle")
#
# logLik10f = sum(dstable(plot_diff10, alpha = sf1f@fit$estimate[1],
#                         beta = sf1f@fit$estimate[2], gamma = sf1f@fit$estimate[3],
#                         delta = sf1f@fit$estimate[4], log = T))
# logLik15f = sum(dstable(plot_diff15, alpha = sf2f@fit$estimate[1],
#                         beta = sf2f@fit$estimate[2], gamma = sf2f@fit$estimate[3],
#                         delta = sf2f@fit$estimate[4], log = T))
# logLik20f = sum(dstable(plot_diff20, alpha = sf3f@fit$estimate[1],
#                         beta = sf3f@fit$estimate[2], gamma = sf3f@fit$estimate[3],
#                         delta = sf3f@fit$estimate[4], log = T))
# logLik25f = sum(dstable(plot_diff25, alpha = sf4f@fit$estimate[1],
#                         beta = sf4f@fit$estimate[2], gamma = sf4f@fit$estimate[3],
#                         delta = sf4f@fit$estimate[4], log = T))
# logLik30f = sum(dstable(plot_diff30, alpha = sf5f@fit$estimate[1],
#                         beta = sf5f@fit$estimate[2], gamma = sf5f@fit$estimate[3],
#                         delta = sf5f@fit$estimate[4], log = T))
# logLik35f = sum(dstable(plot_diff35, alpha = sf6f@fit$estimate[1],
#                         beta = sf6f@fit$estimate[2], gamma = sf6f@fit$estimate[3],
#                         delta = sf6f@fit$estimate[4], log = T))
#
#
# aic10f = 2*10 - 2*logLik10f
# aic15f = 2*15 - 2*logLik15f
# aic20f = 2*20 - 2*logLik20f
# aic25f = 2*25 - 2*logLik25f
# aic30f = 2*30 - 2*logLik30f
# aic35f = 2*35 - 2*logLik35f
#
# bic10f = log(length(plot_diff10))*10 - 2*logLik10f
# bic15f = log(length(plot_diff15))*15 - 2*logLik15f
# bic20f = log(length(plot_diff20))*20 - 2*logLik20f
# bic25f = log(length(plot_diff25))*25 - 2*logLik25f
# bic30f = log(length(plot_diff30))*30 - 2*logLik30f
# bic35f = log(length(plot_diff35))*35 - 2*logLik35f
#
put_matrix
round(put_matrix,2)
xtable_put = xtable(put_matrix, caption = "Put prices for CRIX with different Strikes and Maturities",
align = "l|rrrrrrrr", digits = 2)
xtable_put
?round
setwd("C:/Users/trimborns/Dropbox/PhD/CRIX/quantlets/CRIXhnoptions")
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXhnoptions
# ------------------------------------------------------------------------------
# Description:  CRIXhnoptions provides a matrix that show the prices of
#               Heston Nandi Put Options for different Strikes and different
#               times to maturity. The prices are provided for CRIX and S&P500.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, SP500_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix that show the prices of
#               Heston Nandi Put Options for different Strikes (columns) and
#               different times to maturity (rows). The prices are provided for
#               CRIX (left part of matrix) and S&P500 (right part of matrix).
# ------------------------------------------------------------------------------
# Example:      A matrix that show the prices of
#               Heston Nandi Put Options for different Strikes (columns) and
#               different times to maturity (rows). The prices are provided for
#               CRIX (left part of matrix) and S&P500 (right part of matrix).
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex, CRIXvarreturn, CRIXoutmarket,
#               CRIXoutmarketTERES
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, S&P500, Options,
#               Put Options, Heston Nandi, GARCH
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
#
# please change your working directory
#setwd("C:/...")
#
#install.packages("fOptions")
library(fOptions)
#
plot_crix   = read.csv("crix.csv", header = T, row.names = 1)
index_SP500 = read.csv("SP500_index.csv", header = T)
#
sp_div                = tail(index_SP500$Price, n = 1) /
tail(plot_crix$Price, n = 1)
index_SP500_corrected = index_SP500$Price/sp_div
SP500_returns         = diff(log(index_SP500_corrected))
crix_returns          = diff(log(plot_crix$Price))
#
HNfit1 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0001))
HNfit2 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0002))
HNfit3 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0009))
HNfit4 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0024))
#
HNfit5 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0001))
HNfit6 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0002))
HNfit7 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0009))
HNfit8 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0024))
#
K                    = c(150, 200, 250, 300)
time_option          = c(30, 90, 180, 365)
put_matrix           = matrix(NA, nrow = length(time_option),
ncol = length(K) * 2)
for (j in 1:length(K)){
put_matrix[1,j] = HNGOption(TypeFlag = "p", model = HNfit1$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[1],
r.daily = HNfit1$model[[6]] / time_option[1])$price
put_matrix[2,j] = HNGOption(TypeFlag = "p", model = HNfit2$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[2],
r.daily = HNfit2$model[[6]] / time_option[2])$price
put_matrix[3,j] = HNGOption(TypeFlag = "p", model = HNfit3$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[3],
r.daily = HNfit3$model[[6]] / time_option[3])$price
put_matrix[4,j] = HNGOption(TypeFlag = "p", model = HNfit4$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[4],
r.daily = HNfit4$model[[6]] / time_option[4])$price
#
put_matrix[1,j+4] = HNGOption(TypeFlag = "p", model = HNfit5$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[1],
r.daily = HNfit5$model[[6]] / time_option[1])$price
put_matrix[2,j+4] = HNGOption(TypeFlag = "p", model = HNfit6$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[2],
r.daily = HNfit6$model[[6]] / time_option[2])$price
put_matrix[3,j+4] = HNGOption(TypeFlag = "p", model = HNfit7$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[3],
r.daily = HNfit7$model[[6]] / time_option[3])$price
put_matrix[4,j+4] = HNGOption(TypeFlag = "p", model = HNfit8$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[4],
r.daily = HNfit8$model[[6]] / time_option[4])$price
}
colnames(put_matrix) = c(K, K)
rownames(put_matrix) = time_option
round(put_matrix, 2)
put_matrix
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXhnoptions
# ------------------------------------------------------------------------------
# Description:  CRIXhnoptions provides a matrix that show the prices of
#               Heston Nandi Put Options for different Strikes and different
#               times to maturity. The prices are provided for CRIX and S&P500.
#               Heston and Nandi proposed in their paper "A Closed-Form GARCH
#               Option Valuation Model" a purely stock price based option
#               valuation model. Since for the CRIX doesn't exist any options,
#               the volatility can't be computed from other options. This
#               drawback requires an approach which works without option data.
#               The prices of the S&P500 has been adjusted such that the last
#               price is the same than for the CRIX. By this procedure, the
#               two time series become comparable for different Strikes and
#               Maturities.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, SP500_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix that show the prices of
#               Heston Nandi Put Options for different Strikes (columns) and
#               different times to maturity (rows). The prices are provided for
#               CRIX (left part of matrix) and S&P500 (right part of matrix).
# ------------------------------------------------------------------------------
# Example:      A matrix that show the prices of
#               Heston Nandi Put Options for different Strikes (columns) and
#               different times to maturity (rows). The prices are provided for
#               CRIX (left part of matrix) and S&P500 (right part of matrix).
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex, CRIXvarreturn, CRIXoutmarket,
#               CRIXoutmarketTERES
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, S&P500, Options,
#               Put Options, Heston Nandi, GARCH
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
#
# please change your working directory
#setwd("C:/...")
#
# install and load packages
libraries = c("fOptions")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
#
plot_crix   = read.csv("crix.csv", header = T, row.names = 1)
index_SP500 = read.csv("SP500_index.csv", header = T)
#
sp_div                = tail(index_SP500$Price, n = 1) /
tail(plot_crix$Price, n = 1)
index_SP500_corrected = index_SP500$Price/sp_div
SP500_returns         = diff(log(index_SP500_corrected))
crix_returns          = diff(log(plot_crix$Price))
#
HNfit1 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0001))
HNfit2 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0002))
HNfit3 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0009))
HNfit4 = hngarchFit(crix_returns[-length(crix_returns)],
model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0024))
#
HNfit5 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0001))
HNfit6 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0002))
HNfit7 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0009))
HNfit8 = hngarchFit(SP500_returns[-length(SP500_returns)],
model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0024))
#
K                    = c(150, 200, 250, 300)
time_option          = c(30, 90, 180, 365)
put_matrix           = matrix(NA, nrow = length(time_option),
ncol = length(K) * 2)
for (j in 1:length(K)){
put_matrix[1,j] = HNGOption(TypeFlag = "p", model = HNfit1$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[1],
r.daily = HNfit1$model[[6]] / time_option[1])$price
put_matrix[2,j] = HNGOption(TypeFlag = "p", model = HNfit2$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[2],
r.daily = HNfit2$model[[6]] / time_option[2])$price
put_matrix[3,j] = HNGOption(TypeFlag = "p", model = HNfit3$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[3],
r.daily = HNfit3$model[[6]] / time_option[3])$price
put_matrix[4,j] = HNGOption(TypeFlag = "p", model = HNfit4$model,
S = tail(plot_crix$Price, n = 1), X = K[j],
Time.inDays = time_option[4],
r.daily = HNfit4$model[[6]] / time_option[4])$price
#
put_matrix[1,j+4] = HNGOption(TypeFlag = "p", model = HNfit5$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[1],
r.daily = HNfit5$model[[6]] / time_option[1])$price
put_matrix[2,j+4] = HNGOption(TypeFlag = "p", model = HNfit6$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[2],
r.daily = HNfit6$model[[6]] / time_option[2])$price
put_matrix[3,j+4] = HNGOption(TypeFlag = "p", model = HNfit7$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[3],
r.daily = HNfit7$model[[6]] / time_option[3])$price
put_matrix[4,j+4] = HNGOption(TypeFlag = "p", model = HNfit8$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[4],
r.daily = HNfit8$model[[6]] / time_option[4])$price
}
colnames(put_matrix) = c(K, K)
rownames(put_matrix) = time_option
round(put_matrix, 2)
# ------------------------------------------------------------------------------
# Book: CRIX
# ------------------------------------------------------------------------------
# Quantlet: CRIXoutmarketTERES
# ------------------------------------------------------------------------------
# Description: CRIXoutmarketTERES provides a matrix which shows the risk of
# S&P500, DAX, STI, RTSI and ATHEX against CRIX measured by Expected Shortfall,
# estimated by an Extreme Value Approach (EVT) and Tail Event Risk Expected
# Shortfall (TERES).
# ------------------------------------------------------------------------------
# Usage: -
# ------------------------------------------------------------------------------
# Inputs: crix.csv, SP500_index.csv, DAX_index.csv, STI_index.csv,
# RTSI_index.csv, ATHEX_index.csv
# ------------------------------------------------------------------------------
# Output: Returns a matrix with the EVT and TERES result for S&P500, DAX, STI,
# RTSI, ATHEX and the CRIX.
# ------------------------------------------------------------------------------
# Example: Matrix with the EVT and TERES result for S&P500, DAX, STI, RTSI,
# ATHEX and the CRIX.
# ------------------------------------------------------------------------------
# See also: CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
# CRIXindex, CRIXbtcindex, CRIXvarreturn, CRIXoutmarket, CRIXhnoptions
# ------------------------------------------------------------------------------
# Keywords: CRIX, Index, Cryptocurrency, Crypto, Plot, btc, Bitcoin, TERES, EVT,
# S&P500, DAX, RTSI, STI, ATHEX, Expected Shortfall, ES
# ------------------------------------------------------------------------------
# Author: Simon Trimborn
# ------------------------------------------------------------------------------
rm(list = ls(all = TRUE))
# please change your working directory setwd('C:/...')
#
# install and load packages
libraries = c("fGarch", "expectreg", "evd")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
#
#
plot_crix   = read.csv("crix.csv", header = T, row.names = 1)
index_SP500 = read.csv("SP500_index.csv", header = T)
index_DAX   = read.csv("DAX_index.csv", header = T)
index_STI   = read.csv("STI_index.csv", header = T)
index_RTSI  = read.csv("RTSI_index.csv", header = T)
index_ATHEX = read.csv("ATHEX_index.csv", header = T)
#
EScomp = function(data) {
Stock = data
y     = Stock
y     = diff(log(y))
#
GARCHvola = garchFit(~garch(1, 1), data = y, trace = F)
ytest     = residuals(GARCHvola)/volatility(GARCHvola)
ywhite    = residuals(GARCHvola)/volatility(GARCHvola)
#
windowsize = length(y) - 1
theta      = 0.01
qtheta     = quantile(y, theta)
tau        = theta
for (i in 1:10000) {
etau = expectile(y, tau)
if (etau < qtheta) {
if (tau < 0.9999) {
tau = tau + 1e-04
} else {
break
}
}
if (etau > qtheta) {
if (tau > 1e-04) {
tau = tau - 1e-04
} else {
break
}
} else {
break
}
}
#
results = matrix(0, 5, (length(y) - windowsize))
#
testExp       = c()
testExpFunc   = c()
testHist      = c()
testEvt       = c()
varind        = 0
varianceStore = c()
volaStore     = c()
#
for (z in seq(1, length(y) - windowsize)) {
window = y[z:(z + windowsize)]
whitewindow = ywhite[z:(z + windowsize)]
qtheta = quantile(window, theta)
#
for (i in 1:10000) {
etau = expectile(window, tau)
if (etau < qtheta) {
if (tau < 0.9999) {
tau = tau + 1e-05
} else {
break
}
}
if (etau > qtheta) {
if (tau > 1e-04) {
tau = tau - 1e-05
} else {
break
}
} else {
break
}
}
#
ex       = expectile(window, tau)
expectES = ex * (1 + tau/((1 - 2 * tau) * theta))
#
L     = -whitewindow
zq    = quantile(L, 1 - theta)
thr   = quantile(L, 0.9)
fitty = fpot(L, thr, model = "gpd", std.err = F)
scale = as.numeric(fitty$scale)
shape = as.numeric(fitty$param[2])
evtES = -(zq/(1 - shape) + (scale - shape * thr)/(1 - shape))
#
results[1, z] = GARCHvola@fit$par[1]
results[2, z] = volatility(GARCHvola)[length(volatility(GARCHvola))]
results[3, z] = expectES
results[4, z] = evtES
results[5, z] = tau
}
results
}
#
ES_CRIX  = EScomp(plot_crix$Price)
ES_SP500 = EScomp(index_SP500$Price)
ES_DAX   = EScomp(index_DAX$Price)
ES_STI   = EScomp(index_STI$Price)
ES_RTSI  = EScomp(index_RTSI$Price)
ES_ATHEX = EScomp(index_ATHEX$Price)
#
table_ES = matrix(c(ES_CRIX[4, 1] * ES_CRIX[2, 1] + ES_CRIX[1, 1], ES_CRIX[3, 1],
ES_SP500[4, 1] * ES_SP500[2, 1] + ES_SP500[1, 1], ES_SP500[3, 1], ES_DAX[4, 1] *
ES_DAX[2, 1] + ES_DAX[1, 1], ES_DAX[3, 1], ES_STI[4, 1] * ES_STI[2, 1] +
ES_STI[1, 1], ES_STI[3, 1], ES_RTSI[4, 1] * ES_RTSI[2, 1] + ES_RTSI[1, 1],
ES_RTSI[3, 1], ES_ATHEX[4, 1] * ES_ATHEX[2, 1] + ES_ATHEX[1, 1], ES_ATHEX[3,
1]), nrow = 6, ncol = 2, byrow = T)
colnames(table_ES) = c("EVT", "TERES")
rownames(table_ES) = c("CRIX", "SP500", "DAX", "STI", "RTSI", "ATHEX")
#
table_ES
