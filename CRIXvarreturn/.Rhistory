S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[3], r.daily = HNfit7$model[[6]]/time_option[3])$price
put_matrix[4,j+4] = HNGOption(TypeFlag = "p", model = HNfit8$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[4], r.daily = HNfit8$model[[6]]/time_option[4])$price
}
put_matrix
index_SP500 = time_series_comp[,1]*divisor_time_series_comp[1]
sp_div = tail(index_SP500, n = 1)/tail(crix[,1], n = 1)
index_SP500_corrected = index_SP500[,1]/sp_div
SP500_returns = diff(log(index_SP500_corrected))
crix_returns = diff(log(crix[,1]))
HNfit1 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0011))
HNfit2 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0021))
HNfit3 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0058))
HNfit4 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.009))
HNfit5 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0011))
HNfit6 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0021))
HNfit7 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0058))
HNfit8 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.009))
# HN_call = HNGOption(TypeFlag = "c", model = HNfit$model, S = tail(crix[,1], n = 1), X = 1000,
#                     Time.inDays = 30, r.daily = HNfit$model[[6]])
# HN_put = HNGOption(TypeFlag = "p", model = HNfit$model, S = tail(crix[,1], n = 1), X = 1000,
#                     Time.inDays = 30, r.daily = HNfit$model[[6]])
K = c(150, 200, 250, 300)
time_option = c(30, 90, 180, 365)
put_matrix = matrix(NA, nrow = length(time_option), ncol = length(K)*2)
colnames(put_matrix) = K
rownames(put_matrix) = time_option
#for (i in 1:length(K)){
for (j in 1:length(K)){
put_matrix[1,j] = HNGOption(TypeFlag = "p", model = HNfit1$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[1], r.daily = HNfit1$model[[6]]/time_option[1])$price
put_matrix[2,j] = HNGOption(TypeFlag = "p", model = HNfit2$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[2], r.daily = HNfit2$model[[6]]/time_option[2])$price
put_matrix[3,j] = HNGOption(TypeFlag = "p", model = HNfit3$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[3], r.daily = HNfit3$model[[6]]/time_option[3])$price
put_matrix[4,j] = HNGOption(TypeFlag = "p", model = HNfit4$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[4], r.daily = HNfit4$model[[6]]/time_option[4])$price
put_matrix[1,j+4] = HNGOption(TypeFlag = "p", model = HNfit5$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[1], r.daily = HNfit5$model[[6]]/time_option[1])$price
put_matrix[2,j+4] = HNGOption(TypeFlag = "p", model = HNfit6$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[2], r.daily = HNfit6$model[[6]]/time_option[2])$price
put_matrix[3,j+4] = HNGOption(TypeFlag = "p", model = HNfit7$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[3], r.daily = HNfit7$model[[6]]/time_option[3])$price
put_matrix[4,j+4] = HNGOption(TypeFlag = "p", model = HNfit8$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[4], r.daily = HNfit8$model[[6]]/time_option[4])$price
}
str(index_SP500)
sp_div = tail(index_SP500, n = 1)/tail(crix[,1], n = 1)
index_SP500_corrected = index_SP500/sp_div
SP500_returns = diff(log(index_SP500_corrected))
crix_returns = diff(log(crix[,1]))
HNfit1 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0011))
HNfit2 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0021))
HNfit3 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.0058))
HNfit4 = hngarchFit(crix_returns[-length(crix_returns)], model = list(lambda = -0.5,
omega = var(crix_returns[-length(crix_returns)]),
alpha = 0.1 * var(crix_returns[-length(crix_returns)]), beta = 0.1,
gamma = 0, rf = 0.009))
HNfit5 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0011))
HNfit6 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0021))
HNfit7 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.0058))
HNfit8 = hngarchFit(SP500_returns[-length(SP500_returns)], model = list(lambda = -0.5,
omega = var(SP500_returns[-length(SP500_returns)]),
alpha = 0.1 * var(SP500_returns[-length(SP500_returns)]), beta = 0.1,
gamma = 0, rf = 0.009))
# HN_call = HNGOption(TypeFlag = "c", model = HNfit$model, S = tail(crix[,1], n = 1), X = 1000,
#                     Time.inDays = 30, r.daily = HNfit$model[[6]])
# HN_put = HNGOption(TypeFlag = "p", model = HNfit$model, S = tail(crix[,1], n = 1), X = 1000,
#                     Time.inDays = 30, r.daily = HNfit$model[[6]])
K = c(150, 200, 250, 300)
time_option = c(30, 90, 180, 365)
put_matrix = matrix(NA, nrow = length(time_option), ncol = length(K)*2)
colnames(put_matrix) = K
rownames(put_matrix) = time_option
#for (i in 1:length(K)){
for (j in 1:length(K)){
put_matrix[1,j] = HNGOption(TypeFlag = "p", model = HNfit1$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[1], r.daily = HNfit1$model[[6]]/time_option[1])$price
put_matrix[2,j] = HNGOption(TypeFlag = "p", model = HNfit2$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[2], r.daily = HNfit2$model[[6]]/time_option[2])$price
put_matrix[3,j] = HNGOption(TypeFlag = "p", model = HNfit3$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[3], r.daily = HNfit3$model[[6]]/time_option[3])$price
put_matrix[4,j] = HNGOption(TypeFlag = "p", model = HNfit4$model,
S = tail(crix[,1], n = 1), X = K[j],
Time.inDays = time_option[4], r.daily = HNfit4$model[[6]]/time_option[4])$price
put_matrix[1,j+4] = HNGOption(TypeFlag = "p", model = HNfit5$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[1], r.daily = HNfit5$model[[6]]/time_option[1])$price
put_matrix[2,j+4] = HNGOption(TypeFlag = "p", model = HNfit6$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[2], r.daily = HNfit6$model[[6]]/time_option[2])$price
put_matrix[3,j+4] = HNGOption(TypeFlag = "p", model = HNfit7$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[3], r.daily = HNfit7$model[[6]]/time_option[3])$price
put_matrix[4,j+4] = HNGOption(TypeFlag = "p", model = HNfit8$model,
S = tail(index_SP500_corrected, n = 1), X = K[j],
Time.inDays = time_option[4], r.daily = HNfit8$model[[6]]/time_option[4])$price
}
put_matrix
xtable_put = xtable(put_matrix, caption = "Put prices for CRIX with different Strikes and Maturities",
align = "l|rrrrrrrr", digits = 2)
print(xtable_put, file = "table_put.tex",
hline.after = c(-1, -1, 0, nrow(xtable_put), nrow(xtable_put)))
crix
?write.table
write.table(crix[,1], file = "crix.csv", sep = ",", dec = ".")
write.table(crix[,1], file = "crix.csv", sep = ",", dec = ".", col.names = c("Date", "Price"))
qlet_crix = crix[,1]
colnames(qlet_crix) = c("Date","Price")
colnames(qlet_crix) = c("Price")
str(qlet_crix)
str(as.matrix(qlet_crix))
(as.matrix(qlet_crix))
write.table(qlet_crix, file = "crix.csv", sep = ",", dec = ".")
names(qlet_crix)
?matrix
qlet_crix = matrix(crix[,1], ncol = 1, dimnames = list(rownames(crix[,1], "Price")))
qlet_crix = matrix(crix[,1], ncol = 1, dimnames = list(rownames(crix[,1]), "Price"))
qlet_crix
head(qlet_crix)
str(qlet_crix)
rownames(crix[,1])
names(crix[,1])
qlet_crix = matrix(crix[,1], ncol = 1, dimnames = list(names(crix[,1]), "Price"))
head(qlet_crix)
write.table(qlet_crix, file = "crix.csv", sep = ",", dec = ".")
qlet_crix = matrix(crix[,1], ncol = 2, dimnames = list("Date", "Price"))
qlet_crix = matrix(c(names(crix[,1]), crix[,1]), ncol = 2, byrow = F, dimnames = list("Date", "Price"))
matrix(c(names(crix[,1]), crix[,1]), ncol = 2, byrow = F)
matrix(c(names(crix[,1]), as.numeric(crix[,1])), ncol = 2, byrow = F)
str(matrix(c(names(crix[,1]), as.numeric(crix[,1])), ncol = 2, byrow = F))
qlet_crix = matrix(c(as.Date(names(crix[,1])), crix[,1]), ncol = 2, byrow = F, dimnames = list("Date", "Price"))
matrix(c(as.Date(names(crix[,1])), crix[,1]), ncol = 2, byrow = F)
qlet_crix = matrix(c(as.Date(names(crix[,1])), crix[,1]), ncol = 2, byrow = F, dimnames = list(NULL,c("Date", "Price")))
qlet_cirx
qlet_crix
qlet_crix = matrix(c(as.Date(names(crix[,1]), origin = "1970-01-01"), crix[,1]), ncol = 2, byrow = F, dimnames = list(NULL,c("Date", "Price")))
head(qlet_crix)
str(qlet_crix)
qlet_crix[,1] = as.Date(qlet_crix[,1], origin = "1970-01-01")
head(qlet_crix)
?as.Date
qlet_crix[,1] = as.Date(qlet_crix[,1], origin = "1970-01-01", format = "%Y-%m-%d")
head(qlet_crix)
as.Date(qlet_crix[,1])
as.Date(qlet_crix[,1], origin = "1970-01-01")
qlet_crix[,1] = as.Date(qlet_crix[,1], origin = "1970-01-01")
qlet_crix[,1]
class(qlet_crix[,1]) = as.Date(qlet_crix[,1], origin = "1970-01-01")
qlet_crix[,1]
str(qlet_crix)
?data.frame
qlet_crix = data.frame(c(as.Date(names(crix[,1])), crix[,1]))
head(qlet_crix)
as.data.frame(crix[,1])
str(as.data.frame(crix[,1]))
class(qlet_crix) = data.frame()
as.data.frame(qlet_crix)
qlet_crix = c()
as.data.frame(qlet_crix)
?as.data.frame
as.data.frame(qlet_crix, ncol = 2)
setwd("C:/Users/trimborns/Dropbox/PhD/CRIX/quantlets/CRIXvarreturn")
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXvarreturn
# ------------------------------------------------------------------------------
# Description:  CRIXvarreturn a matrix which compares the absolut return and the
#               variance, computed by a GARCH(1,1) model, of the CRIX and Bitcoin
#               (btc) time series.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example:      A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return,
#               variance, garch, absolut return
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
# please change your working directory
#setwd("C:/...")
# install.packages("fGarch")
library(fGarch)
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc = read.csv("btc_index.csv", header = T, row.names = 1)
return_CRIX = plot_crix$Price[dim(plot_crix)[1]]/plot_crix$Price[1]
return_btc = plot_btc$Price[dim(plot_btc)[1]]/plot_btc$Price[1]
### Variance
var_CRIX = volatility(garchFit(~garch(1,1), data = diff(log(plot_crix$Price)), trace = F))
var_btc = volatility(garchFit(~garch(1,1), data = diff(log(plot_btc$Price)), trace = F))
var_CRIX = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_crix$Price)), trace = F)))
var_btc = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_btc$Price)), trace = F)))
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2, byrow = T)
erg
?matrix
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2, byrow = T,
dimnames = list(c("Return", "Var"), c("CRIX", "btc"))
erg
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2, byrow = T,
dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXvarreturn
# ------------------------------------------------------------------------------
# Description:  CRIXvarreturn a matrix which compares the absolut return and the
#               variance, computed by a GARCH(1,1) model, of the CRIX and Bitcoin
#               (btc) time series.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example:      A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return,
#               variance, garch, absolut return
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
# please change your working directory
#setwd("C:/...")
# install.packages("fGarch")
library(fGarch)
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc = read.csv("btc_index.csv", header = T, row.names = 1)
return_CRIX = plot_crix$Price[dim(plot_crix)[1]]/plot_crix$Price[1]
return_btc = plot_btc$Price[dim(plot_btc)[1]]/plot_btc$Price[1]
### Variance
var_CRIX = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_crix$Price)), trace = F)))
var_btc = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_btc$Price)), trace = F)))
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2, byrow = T,
dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXvarreturn
# ------------------------------------------------------------------------------
# Description:  CRIXvarreturn a matrix which compares the absolut return and the
#               variance, computed by a GARCH(1,1) model, of the CRIX and Bitcoin
#               (btc) time series.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example:      A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return,
#               variance, garch, absolut return
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
# please change your working directory
#setwd("C:/...")
# install.packages("fGarch")
library(fGarch)
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc  = read.csv("btc_index.csv", header = T, row.names = 1)
return_CRIX = plot_crix$Price[dim(plot_crix)[1]] / plot_crix$Price[1]
return_btc  = plot_btc$Price[dim(plot_btc)[1]] / plot_btc$Price[1]
### Variance
var_CRIX  = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_crix$Price)), trace = F)))
var_btc   = sum(volatility(garchFit(~garch(1,1), data = diff(log(plot_btc$Price)), trace = F)))
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2, byrow = T,
dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXvarreturn
# ------------------------------------------------------------------------------
# Description:  CRIXvarreturn a matrix which compares the absolut return and the
#               variance, computed by a GARCH(1,1) model, of the CRIX and Bitcoin
#               (btc) time series.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example:      A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return,
#               variance, garch, absolut return
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
#
# please change your working directory
#setwd("C:/...")
#
# install.packages("fGarch")
library(fGarch)
#
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc  = read.csv("btc_index.csv", header = T, row.names = 1)
#
return_CRIX = plot_crix$Price[dim(plot_crix)[1]] / plot_crix$Price[1]
return_btc  = plot_btc$Price[dim(plot_btc)[1]] / plot_btc$Price[1]
#
### Variance
var_CRIX  = sum(volatility(garchFit(~garch(1,1),
data = diff(log(plot_crix$Price)), trace = F)))
var_btc   = sum(volatility(garchFit(~garch(1,1),
data = diff(log(plot_btc$Price)), trace = F)))
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2,
byrow = T, dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
# ------------------------------------------------------------------------------
# Book:         CRIX
# ------------------------------------------------------------------------------
# Quantlet:     CRIXvarreturn
# ------------------------------------------------------------------------------
# Description:  CRIXvarreturn a matrix which compares the absolut return and the
#               variance, computed by a GARCH(1,1) model, of the CRIX and Bitcoin
#               (btc) time series.
# ------------------------------------------------------------------------------
# Usage:        -
# ------------------------------------------------------------------------------
# Inputs:       crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output:       Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example:      A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also:     CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket,
#               CRIXindex, CRIXbtcindex, CRIXoutmarket, CRIXoutmarketTERES,
#               CRIXhnoptions
# ------------------------------------------------------------------------------
# Keywords:     CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return,
#               variance, garch, absolut return
# ------------------------------------------------------------------------------
# Author:       Simon Trimborn
# ------------------------------------------------------------------------------
rm(list=ls(all=TRUE))
#
# please change your working directory
#setwd("C:/...")
#
# install.packages("fGarch")
library(fGarch)
#
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc  = read.csv("btc_index.csv", header = T, row.names = 1)
#
return_CRIX = plot_crix$Price[dim(plot_crix)[1]] / plot_crix$Price[1]
return_btc  = plot_btc$Price[dim(plot_btc)[1]] / plot_btc$Price[1]
#
### Variance
var_CRIX  = sum(volatility(garchFit(~garch(1,1),
data = diff(log(plot_crix$Price)), trace = F)))
var_btc   = sum(volatility(garchFit(~garch(1,1),
data = diff(log(plot_btc$Price)), trace = F)))
#
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2,
byrow = T, dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
# ------------------------------------------------------------------------------
# Book: CRIX
# ------------------------------------------------------------------------------
# Quantlet: CRIXvarreturn
# ------------------------------------------------------------------------------
# Description: CRIXvarreturn computes a matrix which compares the absolut return
# and the variance, computed by a GARCH(1,1) model, of a CRIX and Bitcoin
# (btc) time series.
# ------------------------------------------------------------------------------
# Usage: -
# ------------------------------------------------------------------------------
# Inputs: crix.csv, btc_index.csv
# ------------------------------------------------------------------------------
# Output: Returns a matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# Example: A matrix with return and variance for btc and the CRIX.
# ------------------------------------------------------------------------------
# See also: CRIXBtcLtcXrp, CRIXESout, CRIXbic, CRIXinmark, CRIXmarket, CRIXindex,
# CRIXbtcindex, CRIXoutmarket, CRIXoutmarketTERES, CRIXhnoptions
# ------------------------------------------------------------------------------
# Keywords: CRIX, Index, Cryptocurrency, Crypto, btc, Bitcoin, return, variance,
# garch, absolut return
# ------------------------------------------------------------------------------
# Author: Simon Trimborn
# ------------------------------------------------------------------------------
rm(list = ls(all = TRUE))
# please change your working directory setwd('C:/...')
# install and load packages
libraries = c("fGarch")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
#
#
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc  = read.csv("btc_index.csv", header = T, row.names = 1)
#
return_CRIX = plot_crix$Price[dim(plot_crix)[1]]/plot_crix$Price[1]
return_btc  = plot_btc$Price[dim(plot_btc)[1]]/plot_btc$Price[1]
# Variance
var_CRIX = sum(volatility(garchFit(~garch(1, 1), data = diff(log(plot_crix$Price)),
trace = F)))
var_btc  = sum(volatility(garchFit(~garch(1, 1), data = diff(log(plot_btc$Price)),
trace = F)))
#
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2,
byrow = T, dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
?trunc
rm(list = ls(all = TRUE))
# please change your working directory
# setwd('C:/...')
# install and load packages
libraries = c("fGarch")
lapply(libraries, function(x) if (!(x %in% installed.packages())) {
install.packages(x)
})
lapply(libraries, library, quietly = TRUE, character.only = TRUE)
plot_crix = read.csv("crix.csv", header = T, row.names = 1)
plot_btc  = read.csv("btc_index.csv", header = T, row.names = 1)
return_CRIX = plot_crix$Price[dim(plot_crix)[1]]/plot_crix$Price[1]
return_btc  = plot_btc$Price[dim(plot_btc)[1]]/plot_btc$Price[1]
var_CRIX = sum(volatility(garchFit(~garch(1, 1), data = diff(log(plot_crix$Price)),
trace = F)))
var_btc  = sum(volatility(garchFit(~garch(1, 1), data = diff(log(plot_btc$Price)),
trace = F)))
erg = matrix(c(return_CRIX, return_btc, var_CRIX, var_btc), ncol = 2, nrow = 2,
byrow = T, dimnames = list(c("Return", "Var"), c("CRIX", "btc")))
erg
